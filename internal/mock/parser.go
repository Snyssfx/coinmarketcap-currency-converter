package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/shopspring/decimal"
)

// ParserMock implements internal.parser
type ParserMock struct {
	t minimock.Tester

	funcParseAmount          func(amount string) (d1 decimal.Decimal, err error)
	inspectFuncParseAmount   func(amount string)
	afterParseAmountCounter  uint64
	beforeParseAmountCounter uint64
	ParseAmountMock          mParserMockParseAmount

	funcParseCurrency          func(cur string) (s1 string, err error)
	inspectFuncParseCurrency   func(cur string)
	afterParseCurrencyCounter  uint64
	beforeParseCurrencyCounter uint64
	ParseCurrencyMock          mParserMockParseCurrency

	funcParseResult          func(result decimal.Decimal) (s1 string)
	inspectFuncParseResult   func(result decimal.Decimal)
	afterParseResultCounter  uint64
	beforeParseResultCounter uint64
	ParseResultMock          mParserMockParseResult
}

// NewParserMock returns a mock for internal.parser
func NewParserMock(t minimock.Tester) *ParserMock {
	m := &ParserMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ParseAmountMock = mParserMockParseAmount{mock: m}
	m.ParseAmountMock.callArgs = []*ParserMockParseAmountParams{}

	m.ParseCurrencyMock = mParserMockParseCurrency{mock: m}
	m.ParseCurrencyMock.callArgs = []*ParserMockParseCurrencyParams{}

	m.ParseResultMock = mParserMockParseResult{mock: m}
	m.ParseResultMock.callArgs = []*ParserMockParseResultParams{}

	return m
}

type mParserMockParseAmount struct {
	mock               *ParserMock
	defaultExpectation *ParserMockParseAmountExpectation
	expectations       []*ParserMockParseAmountExpectation

	callArgs []*ParserMockParseAmountParams
	mutex    sync.RWMutex
}

// ParserMockParseAmountExpectation specifies expectation struct of the parser.ParseAmount
type ParserMockParseAmountExpectation struct {
	mock    *ParserMock
	params  *ParserMockParseAmountParams
	results *ParserMockParseAmountResults
	Counter uint64
}

// ParserMockParseAmountParams contains parameters of the parser.ParseAmount
type ParserMockParseAmountParams struct {
	amount string
}

// ParserMockParseAmountResults contains results of the parser.ParseAmount
type ParserMockParseAmountResults struct {
	d1  decimal.Decimal
	err error
}

// Expect sets up expected params for parser.ParseAmount
func (mmParseAmount *mParserMockParseAmount) Expect(amount string) *mParserMockParseAmount {
	if mmParseAmount.mock.funcParseAmount != nil {
		mmParseAmount.mock.t.Fatalf("ParserMock.ParseAmount mock is already set by Set")
	}

	if mmParseAmount.defaultExpectation == nil {
		mmParseAmount.defaultExpectation = &ParserMockParseAmountExpectation{}
	}

	mmParseAmount.defaultExpectation.params = &ParserMockParseAmountParams{amount}
	for _, e := range mmParseAmount.expectations {
		if minimock.Equal(e.params, mmParseAmount.defaultExpectation.params) {
			mmParseAmount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmParseAmount.defaultExpectation.params)
		}
	}

	return mmParseAmount
}

// Inspect accepts an inspector function that has same arguments as the parser.ParseAmount
func (mmParseAmount *mParserMockParseAmount) Inspect(f func(amount string)) *mParserMockParseAmount {
	if mmParseAmount.mock.inspectFuncParseAmount != nil {
		mmParseAmount.mock.t.Fatalf("Inspect function is already set for ParserMock.ParseAmount")
	}

	mmParseAmount.mock.inspectFuncParseAmount = f

	return mmParseAmount
}

// Return sets up results that will be returned by parser.ParseAmount
func (mmParseAmount *mParserMockParseAmount) Return(d1 decimal.Decimal, err error) *ParserMock {
	if mmParseAmount.mock.funcParseAmount != nil {
		mmParseAmount.mock.t.Fatalf("ParserMock.ParseAmount mock is already set by Set")
	}

	if mmParseAmount.defaultExpectation == nil {
		mmParseAmount.defaultExpectation = &ParserMockParseAmountExpectation{mock: mmParseAmount.mock}
	}
	mmParseAmount.defaultExpectation.results = &ParserMockParseAmountResults{d1, err}
	return mmParseAmount.mock
}

//Set uses given function f to mock the parser.ParseAmount method
func (mmParseAmount *mParserMockParseAmount) Set(f func(amount string) (d1 decimal.Decimal, err error)) *ParserMock {
	if mmParseAmount.defaultExpectation != nil {
		mmParseAmount.mock.t.Fatalf("Default expectation is already set for the parser.ParseAmount method")
	}

	if len(mmParseAmount.expectations) > 0 {
		mmParseAmount.mock.t.Fatalf("Some expectations are already set for the parser.ParseAmount method")
	}

	mmParseAmount.mock.funcParseAmount = f
	return mmParseAmount.mock
}

// When sets expectation for the parser.ParseAmount which will trigger the result defined by the following
// Then helper
func (mmParseAmount *mParserMockParseAmount) When(amount string) *ParserMockParseAmountExpectation {
	if mmParseAmount.mock.funcParseAmount != nil {
		mmParseAmount.mock.t.Fatalf("ParserMock.ParseAmount mock is already set by Set")
	}

	expectation := &ParserMockParseAmountExpectation{
		mock:   mmParseAmount.mock,
		params: &ParserMockParseAmountParams{amount},
	}
	mmParseAmount.expectations = append(mmParseAmount.expectations, expectation)
	return expectation
}

// Then sets up parser.ParseAmount return parameters for the expectation previously defined by the When method
func (e *ParserMockParseAmountExpectation) Then(d1 decimal.Decimal, err error) *ParserMock {
	e.results = &ParserMockParseAmountResults{d1, err}
	return e.mock
}

// ParseAmount implements internal.parser
func (mmParseAmount *ParserMock) ParseAmount(amount string) (d1 decimal.Decimal, err error) {
	mm_atomic.AddUint64(&mmParseAmount.beforeParseAmountCounter, 1)
	defer mm_atomic.AddUint64(&mmParseAmount.afterParseAmountCounter, 1)

	if mmParseAmount.inspectFuncParseAmount != nil {
		mmParseAmount.inspectFuncParseAmount(amount)
	}

	mm_params := &ParserMockParseAmountParams{amount}

	// Record call args
	mmParseAmount.ParseAmountMock.mutex.Lock()
	mmParseAmount.ParseAmountMock.callArgs = append(mmParseAmount.ParseAmountMock.callArgs, mm_params)
	mmParseAmount.ParseAmountMock.mutex.Unlock()

	for _, e := range mmParseAmount.ParseAmountMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1, e.results.err
		}
	}

	if mmParseAmount.ParseAmountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmParseAmount.ParseAmountMock.defaultExpectation.Counter, 1)
		mm_want := mmParseAmount.ParseAmountMock.defaultExpectation.params
		mm_got := ParserMockParseAmountParams{amount}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmParseAmount.t.Errorf("ParserMock.ParseAmount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmParseAmount.ParseAmountMock.defaultExpectation.results
		if mm_results == nil {
			mmParseAmount.t.Fatal("No results are set for the ParserMock.ParseAmount")
		}
		return (*mm_results).d1, (*mm_results).err
	}
	if mmParseAmount.funcParseAmount != nil {
		return mmParseAmount.funcParseAmount(amount)
	}
	mmParseAmount.t.Fatalf("Unexpected call to ParserMock.ParseAmount. %v", amount)
	return
}

// ParseAmountAfterCounter returns a count of finished ParserMock.ParseAmount invocations
func (mmParseAmount *ParserMock) ParseAmountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParseAmount.afterParseAmountCounter)
}

// ParseAmountBeforeCounter returns a count of ParserMock.ParseAmount invocations
func (mmParseAmount *ParserMock) ParseAmountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParseAmount.beforeParseAmountCounter)
}

// Calls returns a list of arguments used in each call to ParserMock.ParseAmount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmParseAmount *mParserMockParseAmount) Calls() []*ParserMockParseAmountParams {
	mmParseAmount.mutex.RLock()

	argCopy := make([]*ParserMockParseAmountParams, len(mmParseAmount.callArgs))
	copy(argCopy, mmParseAmount.callArgs)

	mmParseAmount.mutex.RUnlock()

	return argCopy
}

// MinimockParseAmountDone returns true if the count of the ParseAmount invocations corresponds
// the number of defined expectations
func (m *ParserMock) MinimockParseAmountDone() bool {
	for _, e := range m.ParseAmountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParseAmountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParseAmountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParseAmount != nil && mm_atomic.LoadUint64(&m.afterParseAmountCounter) < 1 {
		return false
	}
	return true
}

// MinimockParseAmountInspect logs each unmet expectation
func (m *ParserMock) MinimockParseAmountInspect() {
	for _, e := range m.ParseAmountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ParserMock.ParseAmount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParseAmountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParseAmountCounter) < 1 {
		if m.ParseAmountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ParserMock.ParseAmount")
		} else {
			m.t.Errorf("Expected call to ParserMock.ParseAmount with params: %#v", *m.ParseAmountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParseAmount != nil && mm_atomic.LoadUint64(&m.afterParseAmountCounter) < 1 {
		m.t.Error("Expected call to ParserMock.ParseAmount")
	}
}

type mParserMockParseCurrency struct {
	mock               *ParserMock
	defaultExpectation *ParserMockParseCurrencyExpectation
	expectations       []*ParserMockParseCurrencyExpectation

	callArgs []*ParserMockParseCurrencyParams
	mutex    sync.RWMutex
}

// ParserMockParseCurrencyExpectation specifies expectation struct of the parser.ParseCurrency
type ParserMockParseCurrencyExpectation struct {
	mock    *ParserMock
	params  *ParserMockParseCurrencyParams
	results *ParserMockParseCurrencyResults
	Counter uint64
}

// ParserMockParseCurrencyParams contains parameters of the parser.ParseCurrency
type ParserMockParseCurrencyParams struct {
	cur string
}

// ParserMockParseCurrencyResults contains results of the parser.ParseCurrency
type ParserMockParseCurrencyResults struct {
	s1  string
	err error
}

// Expect sets up expected params for parser.ParseCurrency
func (mmParseCurrency *mParserMockParseCurrency) Expect(cur string) *mParserMockParseCurrency {
	if mmParseCurrency.mock.funcParseCurrency != nil {
		mmParseCurrency.mock.t.Fatalf("ParserMock.ParseCurrency mock is already set by Set")
	}

	if mmParseCurrency.defaultExpectation == nil {
		mmParseCurrency.defaultExpectation = &ParserMockParseCurrencyExpectation{}
	}

	mmParseCurrency.defaultExpectation.params = &ParserMockParseCurrencyParams{cur}
	for _, e := range mmParseCurrency.expectations {
		if minimock.Equal(e.params, mmParseCurrency.defaultExpectation.params) {
			mmParseCurrency.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmParseCurrency.defaultExpectation.params)
		}
	}

	return mmParseCurrency
}

// Inspect accepts an inspector function that has same arguments as the parser.ParseCurrency
func (mmParseCurrency *mParserMockParseCurrency) Inspect(f func(cur string)) *mParserMockParseCurrency {
	if mmParseCurrency.mock.inspectFuncParseCurrency != nil {
		mmParseCurrency.mock.t.Fatalf("Inspect function is already set for ParserMock.ParseCurrency")
	}

	mmParseCurrency.mock.inspectFuncParseCurrency = f

	return mmParseCurrency
}

// Return sets up results that will be returned by parser.ParseCurrency
func (mmParseCurrency *mParserMockParseCurrency) Return(s1 string, err error) *ParserMock {
	if mmParseCurrency.mock.funcParseCurrency != nil {
		mmParseCurrency.mock.t.Fatalf("ParserMock.ParseCurrency mock is already set by Set")
	}

	if mmParseCurrency.defaultExpectation == nil {
		mmParseCurrency.defaultExpectation = &ParserMockParseCurrencyExpectation{mock: mmParseCurrency.mock}
	}
	mmParseCurrency.defaultExpectation.results = &ParserMockParseCurrencyResults{s1, err}
	return mmParseCurrency.mock
}

//Set uses given function f to mock the parser.ParseCurrency method
func (mmParseCurrency *mParserMockParseCurrency) Set(f func(cur string) (s1 string, err error)) *ParserMock {
	if mmParseCurrency.defaultExpectation != nil {
		mmParseCurrency.mock.t.Fatalf("Default expectation is already set for the parser.ParseCurrency method")
	}

	if len(mmParseCurrency.expectations) > 0 {
		mmParseCurrency.mock.t.Fatalf("Some expectations are already set for the parser.ParseCurrency method")
	}

	mmParseCurrency.mock.funcParseCurrency = f
	return mmParseCurrency.mock
}

// When sets expectation for the parser.ParseCurrency which will trigger the result defined by the following
// Then helper
func (mmParseCurrency *mParserMockParseCurrency) When(cur string) *ParserMockParseCurrencyExpectation {
	if mmParseCurrency.mock.funcParseCurrency != nil {
		mmParseCurrency.mock.t.Fatalf("ParserMock.ParseCurrency mock is already set by Set")
	}

	expectation := &ParserMockParseCurrencyExpectation{
		mock:   mmParseCurrency.mock,
		params: &ParserMockParseCurrencyParams{cur},
	}
	mmParseCurrency.expectations = append(mmParseCurrency.expectations, expectation)
	return expectation
}

// Then sets up parser.ParseCurrency return parameters for the expectation previously defined by the When method
func (e *ParserMockParseCurrencyExpectation) Then(s1 string, err error) *ParserMock {
	e.results = &ParserMockParseCurrencyResults{s1, err}
	return e.mock
}

// ParseCurrency implements internal.parser
func (mmParseCurrency *ParserMock) ParseCurrency(cur string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmParseCurrency.beforeParseCurrencyCounter, 1)
	defer mm_atomic.AddUint64(&mmParseCurrency.afterParseCurrencyCounter, 1)

	if mmParseCurrency.inspectFuncParseCurrency != nil {
		mmParseCurrency.inspectFuncParseCurrency(cur)
	}

	mm_params := &ParserMockParseCurrencyParams{cur}

	// Record call args
	mmParseCurrency.ParseCurrencyMock.mutex.Lock()
	mmParseCurrency.ParseCurrencyMock.callArgs = append(mmParseCurrency.ParseCurrencyMock.callArgs, mm_params)
	mmParseCurrency.ParseCurrencyMock.mutex.Unlock()

	for _, e := range mmParseCurrency.ParseCurrencyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmParseCurrency.ParseCurrencyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmParseCurrency.ParseCurrencyMock.defaultExpectation.Counter, 1)
		mm_want := mmParseCurrency.ParseCurrencyMock.defaultExpectation.params
		mm_got := ParserMockParseCurrencyParams{cur}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmParseCurrency.t.Errorf("ParserMock.ParseCurrency got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmParseCurrency.ParseCurrencyMock.defaultExpectation.results
		if mm_results == nil {
			mmParseCurrency.t.Fatal("No results are set for the ParserMock.ParseCurrency")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmParseCurrency.funcParseCurrency != nil {
		return mmParseCurrency.funcParseCurrency(cur)
	}
	mmParseCurrency.t.Fatalf("Unexpected call to ParserMock.ParseCurrency. %v", cur)
	return
}

// ParseCurrencyAfterCounter returns a count of finished ParserMock.ParseCurrency invocations
func (mmParseCurrency *ParserMock) ParseCurrencyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParseCurrency.afterParseCurrencyCounter)
}

// ParseCurrencyBeforeCounter returns a count of ParserMock.ParseCurrency invocations
func (mmParseCurrency *ParserMock) ParseCurrencyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParseCurrency.beforeParseCurrencyCounter)
}

// Calls returns a list of arguments used in each call to ParserMock.ParseCurrency.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmParseCurrency *mParserMockParseCurrency) Calls() []*ParserMockParseCurrencyParams {
	mmParseCurrency.mutex.RLock()

	argCopy := make([]*ParserMockParseCurrencyParams, len(mmParseCurrency.callArgs))
	copy(argCopy, mmParseCurrency.callArgs)

	mmParseCurrency.mutex.RUnlock()

	return argCopy
}

// MinimockParseCurrencyDone returns true if the count of the ParseCurrency invocations corresponds
// the number of defined expectations
func (m *ParserMock) MinimockParseCurrencyDone() bool {
	for _, e := range m.ParseCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParseCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParseCurrencyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParseCurrency != nil && mm_atomic.LoadUint64(&m.afterParseCurrencyCounter) < 1 {
		return false
	}
	return true
}

// MinimockParseCurrencyInspect logs each unmet expectation
func (m *ParserMock) MinimockParseCurrencyInspect() {
	for _, e := range m.ParseCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ParserMock.ParseCurrency with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParseCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParseCurrencyCounter) < 1 {
		if m.ParseCurrencyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ParserMock.ParseCurrency")
		} else {
			m.t.Errorf("Expected call to ParserMock.ParseCurrency with params: %#v", *m.ParseCurrencyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParseCurrency != nil && mm_atomic.LoadUint64(&m.afterParseCurrencyCounter) < 1 {
		m.t.Error("Expected call to ParserMock.ParseCurrency")
	}
}

type mParserMockParseResult struct {
	mock               *ParserMock
	defaultExpectation *ParserMockParseResultExpectation
	expectations       []*ParserMockParseResultExpectation

	callArgs []*ParserMockParseResultParams
	mutex    sync.RWMutex
}

// ParserMockParseResultExpectation specifies expectation struct of the parser.ParseResult
type ParserMockParseResultExpectation struct {
	mock    *ParserMock
	params  *ParserMockParseResultParams
	results *ParserMockParseResultResults
	Counter uint64
}

// ParserMockParseResultParams contains parameters of the parser.ParseResult
type ParserMockParseResultParams struct {
	result decimal.Decimal
}

// ParserMockParseResultResults contains results of the parser.ParseResult
type ParserMockParseResultResults struct {
	s1 string
}

// Expect sets up expected params for parser.ParseResult
func (mmParseResult *mParserMockParseResult) Expect(result decimal.Decimal) *mParserMockParseResult {
	if mmParseResult.mock.funcParseResult != nil {
		mmParseResult.mock.t.Fatalf("ParserMock.ParseResult mock is already set by Set")
	}

	if mmParseResult.defaultExpectation == nil {
		mmParseResult.defaultExpectation = &ParserMockParseResultExpectation{}
	}

	mmParseResult.defaultExpectation.params = &ParserMockParseResultParams{result}
	for _, e := range mmParseResult.expectations {
		if minimock.Equal(e.params, mmParseResult.defaultExpectation.params) {
			mmParseResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmParseResult.defaultExpectation.params)
		}
	}

	return mmParseResult
}

// Inspect accepts an inspector function that has same arguments as the parser.ParseResult
func (mmParseResult *mParserMockParseResult) Inspect(f func(result decimal.Decimal)) *mParserMockParseResult {
	if mmParseResult.mock.inspectFuncParseResult != nil {
		mmParseResult.mock.t.Fatalf("Inspect function is already set for ParserMock.ParseResult")
	}

	mmParseResult.mock.inspectFuncParseResult = f

	return mmParseResult
}

// Return sets up results that will be returned by parser.ParseResult
func (mmParseResult *mParserMockParseResult) Return(s1 string) *ParserMock {
	if mmParseResult.mock.funcParseResult != nil {
		mmParseResult.mock.t.Fatalf("ParserMock.ParseResult mock is already set by Set")
	}

	if mmParseResult.defaultExpectation == nil {
		mmParseResult.defaultExpectation = &ParserMockParseResultExpectation{mock: mmParseResult.mock}
	}
	mmParseResult.defaultExpectation.results = &ParserMockParseResultResults{s1}
	return mmParseResult.mock
}

//Set uses given function f to mock the parser.ParseResult method
func (mmParseResult *mParserMockParseResult) Set(f func(result decimal.Decimal) (s1 string)) *ParserMock {
	if mmParseResult.defaultExpectation != nil {
		mmParseResult.mock.t.Fatalf("Default expectation is already set for the parser.ParseResult method")
	}

	if len(mmParseResult.expectations) > 0 {
		mmParseResult.mock.t.Fatalf("Some expectations are already set for the parser.ParseResult method")
	}

	mmParseResult.mock.funcParseResult = f
	return mmParseResult.mock
}

// When sets expectation for the parser.ParseResult which will trigger the result defined by the following
// Then helper
func (mmParseResult *mParserMockParseResult) When(result decimal.Decimal) *ParserMockParseResultExpectation {
	if mmParseResult.mock.funcParseResult != nil {
		mmParseResult.mock.t.Fatalf("ParserMock.ParseResult mock is already set by Set")
	}

	expectation := &ParserMockParseResultExpectation{
		mock:   mmParseResult.mock,
		params: &ParserMockParseResultParams{result},
	}
	mmParseResult.expectations = append(mmParseResult.expectations, expectation)
	return expectation
}

// Then sets up parser.ParseResult return parameters for the expectation previously defined by the When method
func (e *ParserMockParseResultExpectation) Then(s1 string) *ParserMock {
	e.results = &ParserMockParseResultResults{s1}
	return e.mock
}

// ParseResult implements internal.parser
func (mmParseResult *ParserMock) ParseResult(result decimal.Decimal) (s1 string) {
	mm_atomic.AddUint64(&mmParseResult.beforeParseResultCounter, 1)
	defer mm_atomic.AddUint64(&mmParseResult.afterParseResultCounter, 1)

	if mmParseResult.inspectFuncParseResult != nil {
		mmParseResult.inspectFuncParseResult(result)
	}

	mm_params := &ParserMockParseResultParams{result}

	// Record call args
	mmParseResult.ParseResultMock.mutex.Lock()
	mmParseResult.ParseResultMock.callArgs = append(mmParseResult.ParseResultMock.callArgs, mm_params)
	mmParseResult.ParseResultMock.mutex.Unlock()

	for _, e := range mmParseResult.ParseResultMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmParseResult.ParseResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmParseResult.ParseResultMock.defaultExpectation.Counter, 1)
		mm_want := mmParseResult.ParseResultMock.defaultExpectation.params
		mm_got := ParserMockParseResultParams{result}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmParseResult.t.Errorf("ParserMock.ParseResult got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmParseResult.ParseResultMock.defaultExpectation.results
		if mm_results == nil {
			mmParseResult.t.Fatal("No results are set for the ParserMock.ParseResult")
		}
		return (*mm_results).s1
	}
	if mmParseResult.funcParseResult != nil {
		return mmParseResult.funcParseResult(result)
	}
	mmParseResult.t.Fatalf("Unexpected call to ParserMock.ParseResult. %v", result)
	return
}

// ParseResultAfterCounter returns a count of finished ParserMock.ParseResult invocations
func (mmParseResult *ParserMock) ParseResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParseResult.afterParseResultCounter)
}

// ParseResultBeforeCounter returns a count of ParserMock.ParseResult invocations
func (mmParseResult *ParserMock) ParseResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParseResult.beforeParseResultCounter)
}

// Calls returns a list of arguments used in each call to ParserMock.ParseResult.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmParseResult *mParserMockParseResult) Calls() []*ParserMockParseResultParams {
	mmParseResult.mutex.RLock()

	argCopy := make([]*ParserMockParseResultParams, len(mmParseResult.callArgs))
	copy(argCopy, mmParseResult.callArgs)

	mmParseResult.mutex.RUnlock()

	return argCopy
}

// MinimockParseResultDone returns true if the count of the ParseResult invocations corresponds
// the number of defined expectations
func (m *ParserMock) MinimockParseResultDone() bool {
	for _, e := range m.ParseResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParseResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParseResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParseResult != nil && mm_atomic.LoadUint64(&m.afterParseResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockParseResultInspect logs each unmet expectation
func (m *ParserMock) MinimockParseResultInspect() {
	for _, e := range m.ParseResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ParserMock.ParseResult with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParseResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParseResultCounter) < 1 {
		if m.ParseResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ParserMock.ParseResult")
		} else {
			m.t.Errorf("Expected call to ParserMock.ParseResult with params: %#v", *m.ParseResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParseResult != nil && mm_atomic.LoadUint64(&m.afterParseResultCounter) < 1 {
		m.t.Error("Expected call to ParserMock.ParseResult")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ParserMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockParseAmountInspect()

		m.MinimockParseCurrencyInspect()

		m.MinimockParseResultInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ParserMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ParserMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockParseAmountDone() &&
		m.MinimockParseCurrencyDone() &&
		m.MinimockParseResultDone()
}
